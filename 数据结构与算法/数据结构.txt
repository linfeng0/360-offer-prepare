数据结构：应届生面试的大头，这个东西很重要！
一种数据结构：逻辑结构、存储结构、数据运算
逻辑结构：集合：同种类型，元素间没有别的关系
	  线性结构：一对一
	  树性结构：一对多
	  图结构：  多对多



常见数据结构：
1.线性表（具有相同数据类型的n个数据元素的有限序列，除第一个节点和最后一个节点以外，其他节点都有其只有一个前驱节点和后继节点）
顺序存储：顺序表
	顺序存储，所有节点连续地存储在一块内存空间中
	逻辑上连续，物理上连续
	随机存取，查找可以根据下标直接锁定元素，时间复杂度位O（1）
	插入和删除，为了保证顺序表物理上的连续性，需要移动操作位置之后的所有元素，时间复杂度O（n）

链式存储：链表（单链表保留一个头指针）
	离散存储，节点在物理内存中的存储不要求连续，每一个节点包括data域和指针域，指针域指向该节点的后驱元素
	逻辑上连续，物理上离散
	

	单链表：	
	非随机存取，查找只能从表头开始，时间复杂度O（n）
	插入和删除，都要找到插入/删除位置的上一个结点，修改操作结点（及前后）的指针域就可以，时间复杂度O（n）
	链表的建立有两种方法：
		1.头插法：新的节点都是直接插入在表头节点的后面（逆序）
		2.尾插法：必须增加一个尾指针来标注当前链表的最后一个节点，新的节点插入到尾节点之后，并将尾指针想后调整（正序）
		单链表的插入：要将s插入到p之后
		s.next = p.next
		p.next = s
	
	静态链表：借助数组来描述线性表的链式结构（结点还是包括数据域和指针域，但是指针域不指向下一个节点的实际地址，而是指向下一个节点在数组中的下标，静态链表也要预先分配一块连续的存储空间，以next=-1表示尾结点）
	
	双链表：双链表节点包括数据域、prior域（指向前驱）、next域（指向后继）
		插入操作：在p之后，插入s
		s.next = p.next
		p.next.prior = s
		s.prior = p
		p.next =s
	双链表的删除某一个元素不需要找到该元素的前驱，直接就可以进行删除操作（因为前驱就是p.prior，不用遍历去找）
	

	循环单链表：尾节点的next指向头节点，就构造了循环单链表

		
比较：
	如果按索引查找操作比较多的话，用顺序表比较好
	如果插入和删除操作比较多的话，用链表比较好
	
	表的长度无法估计的一般用链表来做比较好，链表不用实现估计存储规模，但是链表的存储密度较低
	表的长度确定的，可以直接使用线性表

	顺序表程序实现起来很容易，数组就可以
	链表程序用高级编程语言的类，定义节点的类（包括指针域和数据域）

2.栈和队列：插入和删除受限制的线性表
	栈：
	先进后出，只允许在栈的一端进行插入和删除操作，保留一个栈顶指针
	n个不同元素的进栈，可以得到的不同的出栈序列有C（2n,n）/(n+1)种

	队列：先进先出，一头插入，另一头删除，保留一对指针：队头指针和队尾指针

	都有顺序存储和链式存储的存储实现方法
应用：
	栈：
	    中缀表达式--->后缀表达式（后缀表达式的运算符顺序就是整个运算的顺序，运算符和紧靠在其之前的两个数据组成最小表达式）
	    括号匹配
	    函数递归调用：栈用来保存返回地址和上下文环境
	    递归函数---->非递归函数：对性能要求特别好的时候，可以将递归改成手工栈，自己去控制手工栈的push和pop，来实现递归函数的非递归化，例如树的前序遍历
	    进制转换	
	   

	队列：树的层次遍历
	      队列先进先出又可以存储数据的特性，天生适合做缓冲区
		

树：包含N个节点的树性结构，当然还规定了（只有一个根，根节点没有父节点，也就是只有一个没有父结点的结点；树中的所有节点都可以有0个或多个孩子节点，除了根节点以外的每个结点都有且只有一个父节点）
	高度：树中结点的最大层数
	结点的度：孩子节点的个数
	树的度：树中含有孩子节点的最多的结点的度
	树的结点结构：数据域+指针域（可以含有多个指针域，每个指针域指向对应的孩子结点）
	树的操作包括查询，插入，删除尤其是查询的时间复杂度很大程度上都和树的高度成正比
	树的应用发展而来的其它约束形成的特殊树类型：二叉树--->线索二叉树----> 二叉排序树 ---->二叉平衡树------>B树------>B+树
	
	二叉树：每个结点最多含有两个孩子结点，分为左孩子和右孩子
	
	线索二叉树：利用二叉树的结点中空的指针域来存储前驱后继，方便遍历（树的遍历不能按照指针顺序一步走到底！），按照构造方法（前/中/后序线索化）的不同，指针域的内容也会不同
	线索化以后还是不能解决的是前序线索求前序前驱，后序线索求后序后继
	
	二叉排序树：左孩子比自己小，右孩子比自己大（按中序遍历会得到一个增序的序列）
		因此二叉排序树的构造，对于同样的数，插入顺序不同，结果也不同，可能会退化成单链表
		二叉排序的插入：
			已有不插入，小往左插，大往右插，一直到为空了就找到了插入位置！
			删除：叶子直接删除就可以了！非叶子结点，如果只有一个子树，用子树代替自己
			      如果有两个子树，让Z的直接后继（或者直接前驱）代替自己

	二叉平衡树：在二叉排序树的基础上，约束左右子树的高度差绝对值（称为平衡因子）小于2（克服了二叉排序树会退化成单链表的缺点，由于新的约束，导致在插入删除的时候，对树的结点调整变得复杂（需要旋转：左左插入导致失衡右转，右右插入导致失衡左转，左右插入导致失衡先左转再右转，右左插入导致失衡先右转后左转）
			
	

	B树：
	在二叉平衡树的基础上，允许每个结点存储多个数据域，结点内的数据按序排列，m个关键字对应m+1个指针域，同时满足平衡因子为0）
		
	


	B+树：



	哈夫曼树：
		结点带权，根结点到任意结点的路径长度与该结点的权值相乘，就是该结点的带权路径长度！
		树中所有结点的带权路径长度之和成为该树的带权路径长度（WPL）！
		haffuman树是一种WPL最小的二叉树！
		构造方法：所有结点组成一个集合，挑出最小的两个配对！配对后生成的父结点权值为孩子节点权值的和，将之插入结点结点，重复以上！到最后只有一个节点！
		huffuman编码相比固定长度编码起到压缩编码长度的作用！
	
	树的遍历：前/中/后、深度遍历，层次遍历	
	
	
图：多对多的关系
	图的存储：邻接矩阵、邻接表、邻接多重表、十字链表（稀疏矩阵也有用到！）	
	图的遍历：深度优先搜索、广度优先搜索！
	图的应用：
		最小代价生成树、最短路径、拓扑排序、关键路径

	邻接矩阵：无向图：m行n列的值为1，代表结点m与结点n直接相连，为0则不相连；无向图的邻接矩阵是个对称矩阵
		  有向图：行是出度，列是入度

	邻接表：链表穿串，在串上的结点都是直接相连的！
	

	有关图的几种算法：
		深度优先搜索、广度优先搜索
		连通图的最小生成树：
		  普里姆算法：
			1.向空树中添加图的任意一个结点v;
			2.循环开始
				找(u,v)使u属于树，v属于图中除了树包含的结点以外的结点，且保证(u,v)最小
				把v和(u,v)添加到树中
			一直到树把连通图中的所有结点都包含了为止
		  克鲁斯卡尔算法：
			循环执行：
				1.找到途中权值最小的边以及边两头的结点，如果这条边添加到树中与树中已经存在的边不构成回路就添加到树中，如果构成回路，则舍弃这条边，找次小的边
			一直到树包含图的所有结点

		最短路径问题：广度优先搜索可以找到无权图（有环也没有关系，把所有的路径找出来比较拿最短）的最短路径
		  狄杰斯特尔算法：求单源最短路径问题（从一个指定的源点到途中其他所有点的最短路径）
			1.初始化一个
			
