1.python常用的数据类型：
	不可变对象：number（int、float），str，tuple
	可变对象：list，dict，set
	不可变对象的修改：由于对象不可变，所以修改一个可变对象，需要新建一个对象（开辟一块新的内存空间），并将引用指向新的对象
	可变对象的修改：因为对象可以原地操作，所以不会新建对象，而是直接在原地操作
		所以当两个引用同时指向一个可变对象的时候，对其中一个引用的操作会同步到另一个引用：
		a = [];b = a;a.append(1),print(b) #b = [1]
		a = 1;b=a;a=2;print(b) #b=1


2.python函数传参：
	python参数的种类：位置参数，默认参数，可变参数，关键字参数，命名关键字参数
	python函数的传参都是在函数内部域新建一个引用，指向对应传入参数（这一点很重要）
	因此，传入的是可变对象的话，函数内部对参数的修改在函数外部有效，
	传入的是不可变对象的话，函数内部对参数的修改在函数外部无效，
	还要注意的是，python函数的传参的顺序要严格按照以上顺序传入（尤其是可变参数（元组）和关键字参数（字典））
	另外，默认参数一般不要使用可变对象，因为函数的调用次数并不只有一次，当默认参数使用可变对象时，函数的第二次调用，默认参数的值将是第一次函数调用时调整后的值，除非我们在程序中需要这么做，否则应当避免使用可变对象做默认参数。

3.python的深拷贝，浅拷贝：
	python对象的拷贝大致分为三种：1.复制 2.浅拷贝 3.深拷贝
	1.复制（直接赋值引用）,指向同一地址,两个引用操作完全是同一个对象
		a = [1,2,[3,4],5]
		b = a
			#id(a) = id(b) 成立
		a.append(6) 
		print(b)  # [1,2,[3,4],5,6]
	
	2.浅拷贝(copy.copy(obj)),拷贝了对象本身，但是对象内的字对象是没有递归拷贝的，即浅拷贝生成了一个新的对象，但是浅拷贝生成的新对象与原来对象的子对象是同一个对象
		import copy
		a = [1,2[3,4],5]
		b = copy.copy(a)
			#id(a)!=id(b)  id(a[2]) = id(b[2])
		a.append(6) #a:[1,2,[3,4],5,6] b:[1,2,[3,4],5]
		a[2].append(7)	#a:[1,2,[3,4,7],5,6] b:[1,2,[3,4,7],5]
	
	3.深拷贝(copy.deepcopy(obj)),递归了拷贝了整个对象（包括子对象），所以两个引用的操作实际上是在操作两个不同的对象
		import copy
		a = [1,2[3,4],5]
		b = copy.deepcopy(a)
			#id(a)!=id(b) id(a[2])!=id(b[2])
		a.append(6) #a:[1,2,[3,4],5,6] b:[1,2,[3,4],5]
		a[2].append(7) #a:[1,2[3,4,7],5,6] b:[1,2,[3,4],5]

	总结，复制：完全操作同一个对象，两个引用的操作相互影响
	      浅拷贝：复制了对象的外层，但是对象的子对象还是指向同一地址，对于外层对象的操作，互不影响，子对象操作相互影响
	      深拷贝：复制了整个对象，两个引用指向地址完全无关的对象，所以操作互不影响
	

4.python元类
	元类的概念：说元类，我们不免要提到的是python的类(class)，
	python类是负责生成类实例对象(instance)的一段代码，带括号调用这个类的时候，返回的是类的实例对象，不带括号，返回的是类本身
	那么在python我们怎么去构造一个类呢？
	第一种方法就是class关键字静态地来写一个类，
	python 中类也是对象，那我们需要动态地来生成类时，用什么呢？答案就是元类(metaclass)。所以元类就是用来生成类对象的类！
	好，串一下流程：
		Myclass = Metaclass() 元类生成类对象
		MyobjectofMyclass = Myclass() 类生成类实例对象
	进一步理解一下：
		我们知道python中的所有东西都是对象，对象都是由类创建而来的，python常见的类有number/str/tuple/list/dict/set/function等等等等，我们可以用对象的__class__属性(obj.__class__)或者用type(obj)来查看对象是由哪个类创建的(也就是说对象是哪一个类的实例)，那么思考一下obj.__class__.__class__或者type(type(obj))会返回什么？
		a = int
		a.__class__	#<class int>
		a.__class__.__class__ #<class type>
	答案是type，type不是用来返回对象的类的函数吗？原来在python中的type函数有两种用法，一种方法我们刚刚用过，用来返回对象的所属类，另一种方法：
		type(class_name,(父类元组),{属性字典})
		用来生成一个类对象，这下明白了，原来python中的类最终都是由type生成的
	
	正式引进元类的概念：python中一切对象都是由类生成，元类就是生成类的类。type是python的内建元类，我们可以用class关键字来静态地写一个类，也可以用type元类来动态地生成一个类,当然我们也可以自己创建自己的元。	
	__metaclass__属性，在类中添加的metaclass属性，用于指定类的元类
	没有添加metaclass属性的话默认会用type，但是我们去调类的metaclass属性的时候会提示该类没有metaclass属性(（has no attribution '__metaclass__')
	这是时候，我们先来关注一下类实例对象的整个创建过程：
		表面上，我们用class关键字写一段代码声明一个类，然后带括号调用该类就可生成一个类实例对象。
		实际上，python解释器在底层做了这些工作：
		1.加载到类代码的时候，python解释器并没有直接在内存新建一个类对象，而是先去找这个类对象的metaclass属性，
		2.如果有，就用metaclass指定的元类的new方法新建一个类，在用元类的init方法初始化这个类，这时候，内存中才有了我们声明的类的类对象，跳到5
		3.如果没有，找它的继承类的metaclass属性，转2，没找到重复3，如果所有父类中都没有metaclass属性，跳4
		4.如果遍历整个父系都没有metaclass属性，再找整个模块的metaclass，找到了返回2，如果还是没有，用python内建元类type来生成我们声明的类，声明的过程和2类似。
		5.生成了类对象以后，用类对象的new方法新建一个类实例对象，在用类对象的init方法初始化这个实例！

	我们自定义的元类，返回值的是type或子类化type，也就是要能生成一个类对象的东西（函数和类都可以），对元类中的new方法和init方法重写就可以自由地创造出我们需要的类。
	元类的复杂程度很高，它的作用主要是：
		1.拦截类的创建
		2.修改类
		3.返回修改后的类	
	def func_metaclass(future_class_name,future_class_parents,future_class_attr):
		'''对属性和方法进行修改'''
		pass
		return type(future_classname,future_class_parents,future_class_attr)
	
	class Metaclass(type):
		def __new__(cls,future_class_name,future_class_parents,future_class_attr):
			'''修改'''
			pass
			return super(Metaclass,cls).__new__(cls,name,bases,dict)
	__metaclass_ = func_metaclass #模块内的metaclass
	class A(object):
		__metaclass__=Metaclass
		pass



	一般来说我们不需要用元类来进行对类的修改，如果需要在不修改源码的情况下动态地修改一个类，我们可以使用：
	1.猴子补丁
	2.装饰器（一般用于函数的修改）
	3.class decorators

	
		


5.python的三种方法：静态方法，类方法，实例方法
	静态方法：
	@staticmethod，通过类直接调用，不需要实例对象，不传self和cls
		不会访问类的内部属性和方法

	类方法：传入的第一个参数是cls，也就是类本身，而不是实例对象
	@classmethod，调用传入的self是类本身，调用方法是也必须是类的公有属性
		类方法只能操纵类的公有属性

	实例方法：没有装饰器，第一个参数self传入的是实例对象
	
	区别标准：
	静态方法不与类、类实例进行绑定，可以由类和类实例调用
	类方法与类进行绑定，可以由类和类实例调用
	实例方法与类实例进行绑定，只能实例化以后由类实例对象调用	


	方法这么多？什么时候用呢？
	一切逻辑上不依赖于类与实例的方法，不会对类内部进行访问的方法，使用静态方法，要注意的是，程序中的静态方法应该避免使用太多

	类方法一般做两种用途：1.工厂方法，用来在生成实例之前做一些预处理，一般return cls(处理后参数)
		  	      2.静态方法调用静态方法，可以代替地来用类方法来调用静态方法（实际上来说也应该是的，因为静态方法写在类里面，调用静态方法，就是访问了类内部，不宜用静态方法，否则需要硬编码），用cls去替代硬编码

	（硬编码的缺点：1.写定的东西，一旦前面改了，后边都要跟着改，不改就逻辑错误
			2.没有多态可言（自己胡乱总结的一点）
					
	但凡是需要对于具体实例结果不同的情况，都应该使用实例方法（开发时一般都是使用实例方法）
	属性方法等到讲了python的类变量（私有变量）以后再说



6.python中的类变量和实例变量:
	类变量：类在定义时就生成了的变量，实例公有的变量，所有实例都可以访问的变量，一般由类方法进行修改
	实例变量：为实例单独绑定的变量，只有当前实例可以访问

7.python 中的下划线：
	前后双下划线：自己定义的对象不要使用这种命名格式，特指python的魔术对象，有官方文档说明其用途，比如__init__,__new__,__slot__,__name__
	双下划线：私有成员，只有类本身可以访问，连类的子类都不可以访问。
		名字的改编:__name----> _classname__name，对解释器起作用，在类中定义，在类的实例对象中无法直接访问
	单下划线开头：保护变量或方法（一种规定），可以由类本身和子类访问
		使用from module import * 不会导入这样，使用import module会导入
	单下划线结尾：为了区别python关键字，class_,int_
		
	

8.python推导式（list推导式，set推导式，dict推导式，生成器推导式）
	写几个看一下就知道了：
				符号是关键
	list 推导式：[i for i in range(20)]
		 <----[exp1 if condition else exp2 for x in data]/[x for x in data if condition]

	dict推导式：{i:i%2==0 for i in range(20)} <------{key:value 循环体}

	set推导式：{i**2 for i in [1,2,1,4]}  
		<------{x for x in data if condition}/{exp1 if condition else exp2 for x in data}

	生成器推导式：(i for i in range(20)) 
		<-----(x for x in data if condition)/(exp1 if condition else exp2 for x in data)

9.python自省
	有时候，我们在对一个对象进行操作的时候，比如调用某一个类的方法，我们并不知道这个类是否有这样的方法，甚至我们连我们拿到的对象类型都不一定很清楚（面向对象语言从来只干两件事：1.找对象，2.搞对象），这种情况就相当于我们在搞对象之前，对象都没有找明白，这是很糟糕的。
	而python提供了非常友好的自省函数，自省库，调用这些函数可以让对象告诉我们它是什么，它有什么，这个过程就叫自省。常见的自省函数：
	help，dir，type，isinstance，hasattr，getattr，setattr
	用于自省的模块，type模块定义了python的所有内置类型结合isintance使用
	




10.生成器与迭代器
	生成器：边循环，边计算，next方法返回下一个生成的值，没有就跑出StioIteartion异常
		a)生成器推导式，b)yield语句
		好处：节省空间

	可迭代对象：凡是能被for循环作用的对象都称作迭代器，list，str，tuple，dict，set，生成器
	迭代器：可以被next函数调用并不断生成值的对象叫做迭代器
				




11.with语法与上下文管理器：
	python3新增的 with语法：
		with expression (as variable):
			with-block
	如：
		with open('/Users/michael/test.txt', 'w') as f:
    			f.write('Hello, world!')
	
	expression就是一个上下文管理器，定义了__enter__方法和__exit__方法
	with语句执行：	上下文管理器的enter方法---->with-block----->上下文管理的exit方法
	as varible是把上下文管理器的enter方法的返回值复制给variable

	自定义上下文管理器：	
		a)自定义__enter__方法和__exit__方法
		b)contextlib模块的contextmanager装饰器+生成器函数yield
			yield之前：enter
			yield之后：exit
			yield的返回值是上下文管理器enter的返回值
			import threading.Lock()
			Lock = threading.Lock()
			import
			@contextmanager
			def locked(Lock):
				Lock.required()
				try:	
					yield 
				finally:
					Lock.release()

12.如何理解python中的if __name__ == "__main__"
	python程序的模拟程序入口
	要理解一下__name__反应的是什么：
		__name__ 在当前python程序直接执行值为__main__
			 在当前python程序以模块导入时为当前程序文件的文件名（不带后缀）

	所以，'if __name__=='__main__:'的语句体如果当前模块是在被导入的情况下运行，是不会执行的
			


13.python闭包
	python部分支持面向函数编程，对于面向函数编程，函数是第一公民，函数式编程最大的要一个特点就是函数可以作为参数传入另一个函数，函数的返回值也可以是函数，函数内部可以定义函数。
	这种时候就不免碰到了函数嵌套的问题，因此有了闭包，闭包是函数式编程中重要的语法结构。
	正常来说一个函数只能访问函数本身作用的局部变量，访问外部作用域的变量的时候就会报错
	而闭包中：外部函数内部的函数访问外部函数的作用域，其实是因为函数式语言会把内嵌函数定义时涉及的引用环境和本身函数体打包成一个整体，这样，内嵌函数就可以访问外套函数的局部变量了
	闭包需要注意的是：
		内嵌函数只能访问不能修改外套函数的局部变量，要修改，用可变对象或者在变量前声明nonlocal

14.python面向切面编程与装饰器
	面向切面编程：函数在执行的过程中转入另一段




15.__metaclass__,__init__,__new__,__call__

16.python实现单例模式

17.python为什么不需要函数重载（python的鸭子特性

18.python的GIL锁

19.python多进程与多线程

20.协程

21.python匿名函数（lambda表达式）

22.python面向函数编程与高阶函数（应该放到闭包之前）

23.python的垃圾回收机制

24.read，readline和readlines

25.python类
	a）python元类
	b）python类的创建过程
	c）__init__和__new__方法
	d）__slot__属性
	e）__dict__属性
	
26.super方法在新式类中的使用

27.python的内存池机制

28.三种描述符：@staticmethod，@classmethod，@property

29.python字符串与字节序列

30.super方法


